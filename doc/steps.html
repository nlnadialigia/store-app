<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
  <title>STORE APP</title>
</head>

<body>
  <section>
    <h2>Criando o projeto</h2>
    <div class="formattedText" data-external-links="">
      <p>Criar um projeto com Nest é bem fácil, o próprio framework disponibiliza uma ferramenta de linha de comando
        (CLI)
        para que não tenhamos muito trabalho instalando e configurando vários pacotes diferentes usando o NPM. </p>
      <p>Para criar um novo projeto Nest, tudo que precisamos fazer é usar o comando abaixo no terminal, em um diretório
        de
        sua preferência, informando o nome do projeto logo após o <code>new</code>. No nosso caso, o projeto se chamará
        <code>loja</code>.
      </p>
      <pre
        class="prettyprint"><code class="hljs language-java" id="0">npx <span class="hljs-meta">@nestjs</span>/cli <span class="hljs-keyword">new</span> <span class="hljs-title class_">loja</span></code><button type="button" class="clipit" onclick="copyToClickBoard(0)">Copiar código</button></pre>
      <p>Este comando pode demorar um pouco dependendo da sua conexão de internet, isso por que ele vai criar uma nova
        pasta
        com o mesmo nome do projeto, criar também o <code>package.json</code> que o Node precisa para gerenciar as
        dependências do projeto e baixar todas as dependências necessárias para a execução do Nest.</p>
      <p>Após este processo finalizar, podemos entrar na pasta do projeto e usar o comando <code>npm start</code> para
        iniciar o projeto. Porém, como estamos em desenvolvimento, é mais interessante que usemos o servidor de
        desenvolvimento, já que este observa as mudanças que faremos nos arquivos e automaticamente reinicia o servidor
        para
        que possamos testar nossas mudanças no navegador ou no postman. </p>
      <p>Para iniciar o servidor de desenvolvimento, basta usar o comando <code>npm run start:dev</code>. Lembre-se de
        parar
        o servidor anterior caso tenha iniciado. Você pode fazer isso com o atalho de teclado <code>CTRL + C</code> no
        terminal.</p>
    </div>
  </section>

  <section>
    <h2>Cadastro de usuários</h2>
    <div class="formattedText" data-external-links="">
      <p>Antes de começar a fazer todo o cadastro de usuário, certifique-se que apagou os arquivos que não vamos
        precisar
        para o nosso projeto. São estes: <code>app.service.ts</code>, o <code>app.e2e-spec.ts</code> e
        <code>app.controller.ts</code> que estão dentro de <code>src</code>. Também apague as referências para estes
        arquivos dentro do <code>app.module.ts</code>. O <code>app.module.ts</code> deve ficar como o código abaixo:
      </p>
      <pre
        class="prettyprint"><code class="hljs language-kotlin" id="1a"><span class="hljs-keyword">import</span> { Module } from <span class="hljs-string">'@nestjs/common'</span>;
    
    <span class="hljs-meta">@Module({
      imports: [],
    })</span>
    export <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> {}</code><button type="button" class="clipit" onclick="copyToClickBoard('1a')">Copiar código</button></pre>
      <p>Depois disso, estamos prontos para iniciar! Sabemos que para tornar possível cadastrar um usuário, precisamos
        de
        uma rota que possa receber os dados do usuário via POST. Para isso, precisamos de um controller. </p>
      <p>Vamos criar uma nova pasta dentro de <code>src</code> para agruparmos códigos que lidam com o usuário, o nome
        dessa
        pasta será <code>usuario</code> e dentro dela, criaremos dois arquivos, estes são:
        <code>usuario.controller.ts</code> e <code>usuario.module.ts</code>. O controller terá um código semelhante a
        este:
      </p>
      <pre class="prettyprint"><code class="hljs language-typescript" id="1b"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Body</span>, <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Post</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@nestjs/common"</span>;
    
    <span class="hljs-meta">@Controller</span>(<span class="hljs-string">'/usuarios'</span>)
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UsuarioController</span> {
    
        <span class="hljs-meta">@Post</span>()
        <span class="hljs-keyword">async</span> <span class="hljs-title function_">criaUsuario</span>(<span class="hljs-params"><span class="hljs-meta">@Body</span>() dadosDoUsuario</span>) {
                    <span class="hljs-keyword">return</span> dadosDoUsuario;
        }
    
    }</code><button type="button" class="clipit" onclick="copyToClickBoard('1b')">Copiar código</button></pre>
      <p>O módulo de usuário por outro lado, será apenas uma classe com o decorator <code>@Module()</code> adicionando
        nosso
        controller na configuração de controllers do módulo.</p>
      <pre
        class="prettyprint"><code class="hljs language-python" id="1c"><span class="hljs-keyword">import</span> { Module } <span class="hljs-keyword">from</span> <span class="hljs-string">"@nestjs/common"</span>;
    <span class="hljs-keyword">import</span> { UsuarioController } <span class="hljs-keyword">from</span> <span class="hljs-string">"./usuario.controller"</span>;
    
    <span class="hljs-meta">@Module(<span class="hljs-params">{
        controllers: [UsuarioController],
    }</span>)</span>
    export <span class="hljs-keyword">class</span> <span class="hljs-title class_">UsuarioModule</span> {}</code><button type="button" class="clipit" onclick="copyToClickBoard('1c')">Copiar código</button></pre>
      <p>Com isso, estamos quase prontos para receber dados via POST no endereço <code>localhost:3000/usuarios</code>. O
        último ponto é adicionar nosso módulo de usuário na árvore de módulos da aplicação Nest, como ilustra o código
        abaixo do arquivo <code>app.module.ts</code>:</p>
      <pre
        class="prettyprint"><code class="hljs language-python" id="1d"><span class="hljs-keyword">import</span> { Module } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
    <span class="hljs-keyword">import</span> { UsuarioModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./usuario/usuario.module'</span>;
    
    <span class="hljs-meta">@Module(<span class="hljs-params">{
      imports: [UsuarioModule],
    }</span>)</span>
    export <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> {}</code><button type="button" class="clipit" onclick="copyToClickBoard('1d')">Copiar código</button></pre>
      <p>Ainda precisamos, de alguma forma, salvar os dados do usuário em nosso banco em memória. Para isso, criaremos
        nosso
        repositório de usuários, o nome do arquivo será <code>usuario.repository.ts</code> e ficará dentro da mesma
        pasta do
        controller de usuário:</p>
      <pre class="prettyprint"><code class="hljs language-typescript" id="1e"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@nestjs/common"</span>;
    
    <span class="hljs-meta">@Injectable</span>()
    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UsuarioRepository</span> {
        <span class="hljs-keyword">private</span> usuarios = [];
    
        <span class="hljs-keyword">async</span> <span class="hljs-title function_">salvar</span>(<span class="hljs-params">usuario</span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">usuarios</span>.<span class="hljs-title function_">push</span>(usuario);
        }
    }</code><button type="button" class="clipit" onclick="copyToClickBoard('1e')">Copiar código</button></pre>
      <p>Também precisamos adicionar o nosso repositório dentro do módulo de usuário, para que o Nest consiga injetar
        objetos dessa classe em nosso controller:</p>
      <pre
        class="prettyprint"><code class="hljs language-python" id="1f"><span class="hljs-keyword">import</span> { Module } <span class="hljs-keyword">from</span> <span class="hljs-string">"@nestjs/common"</span>;
    <span class="hljs-keyword">import</span> { UsuarioController } <span class="hljs-keyword">from</span> <span class="hljs-string">"./usuario.controller"</span>;
    <span class="hljs-keyword">import</span> { UsuarioRepository } <span class="hljs-keyword">from</span> <span class="hljs-string">"./usuario.repository"</span>;
    
    <span class="hljs-meta">@Module(<span class="hljs-params">{
        controllers: [UsuarioController],
        providers: [UsuarioRepository]
    }</span>)</span>
    export <span class="hljs-keyword">class</span> <span class="hljs-title class_">UsuarioModule</span> {}</code><button type="button" class="clipit" onclick="copyToClickBoard('1f')">Copiar código</button></pre>
      <p>Agora, em nosso controller, podemos receber o repositório através do construtor e usar o método salvar ao
        receber
        os dados do usuário.</p>
      <pre class="prettyprint"><code class="hljs language-less" id="1g"><span class="hljs-variable">@Post</span>()
    async <span class="hljs-built_in">criaUsuario</span>(<span class="hljs-variable">@Body</span>() dadosDoUsuario) {
        <span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.usuarioRepository</span><span class="hljs-selector-class">.salvar</span>(dadosDoUsuario);
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">dadosDoUsuario</span>;
    }</code><button type="button" class="clipit" onclick="copyToClickBoard('1g')">Copiar código</button></pre>
      <p>Ótimo, já podemos cadastrar usuários, agora precisamos listá-los. Como fazer isso? </p>
      <p>As mudanças que precisamos fazer são mínimas. Primeiro, precisamos devolver a lista de usuários que foram
        salvos no
        nosso <code>usuario.repository.ts</code> com um método novo que chamaremos de <code>listar</code>: </p>
      <pre class="prettyprint"><code class="hljs language-csharp" id="1h"><span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">listar</span>()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.usuarios;
    }</code><button type="button" class="clipit" onclick="copyToClickBoard('1h')">Copiar código</button></pre>
      <p>E em nosso <code>usuario.controller.ts</code> faremos um novo método que responde por GET e usa o método
        <code>listar</code> para devolver a lista de usuários que é retornada pelo repositório.
      </p>
      <pre class="prettyprint"><code class="hljs language-kotlin" id="1i"><span class="hljs-meta">@Get()</span>
        async listUsuarios() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.usuarioRepository.listar();
    }</code><button type="button" class="clipit" onclick="copyToClickBoard('1i')">Copiar código</button></pre>
      <p>Agora podemos tanto cadastrar, quanto listar usuários! </p>
    </div>
  </section>

  <section>
    <h2>Cadastro de produtos</h2>
    <div class="formattedText" data-external-links="">
      <p>Para o cadastro de produtos, teremos a mesma estrutura de arquivos e a lógica será praticamente idêntica.
        Faremos
        da forma mais simples possível e vamos ajustando conforme for necessário. Dito isso, replique a estrutura que
        usamos
        para cadastrar usuários fazendo as devidas alterações para funcionar para produtos.</p>
      <p>Criaremos uma nova pasta chamada <code>produto</code> dentro de <code>src</code> e nela criaremos os arquivos
        <code>produto.controller.ts</code>, <code>produto.repository.ts</code> e <code>produto.module.ts</code>.
      </p>
      <p>Teremos a rota que responde via GET e via POST. Quando recebermos um GET, listaremos os produtos cadastrados,
        quando recebermos um POST, iremos capturar os dados que vierem no corpo de requisição e salvar estes dados no
        repositório de produtos. </p>
      <p>O JSON abaixo é um exemplo que apresenta todos os dados necessários para cadastrar um produto:</p>
      <pre
        class="prettyprint"><code class="hljs language-json" id="2"><span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"nome"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Figura de ação Marvel Homem Aranha Olympus Homem Aranha E6358 de Hasbro Classic"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"valor"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">70.0</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"quantidadeDisponivel"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"descricao"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Produto novo, bem acabado, alegria para colecionadores"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"caracteristicas"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"nome"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Fabricante"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"descricao"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Iron Studios"</span>
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"nome"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"material"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"descricao"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Plástico"</span>
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"imagens"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"url"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"https://i.imgur.com/dwDZICq.jpg"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"descricao"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Imagem do Homem Aranha"</span>
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"categoria"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Colecionáveis"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"dataCriacao"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2022-10-12T14:22:53.496Z"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"dataAtualizacao"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2022-10-12T14:22:53.496Z"</span>
    <span class="hljs-punctuation">}</span></code><button type="button" class="clipit" onclick="copyToClickBoard(2)">Copiar código</button></pre>
      <p>Note que temos o nome do produto, valor, quantidade disponível, descrição, características, imagens, categoria
        e
        datas de criação e atualização do produto.</p>
      <p>Não se preocupe ainda com a validação destas informações ou mesmo com a associação de quem foi o usuário que
        cadastrou um produto específico. Teremos uma atividade específica para isso.</p>
    </div>
  </section>

  <section>
    <h2>Validação do usuário</h2>
    <div class="formattedText" data-external-links="">
      <p>Antes de iniciar a escrita das validações em si, precisamos primeiramente instalar as bibliotecas que se
        integram
        ao Nest e seus pipes, nos permitindo escrever essas validações de forma muito simples. Essas bibliotecas são a
        <code>class-validator</code> e a <code>class-transformer</code>. Faremos isso digitando o seguinte comando no
        terminal na raiz do projeto:
      </p>
      <pre
        class="prettyprint"><code class="hljs language-cpp" id="3">npm install <span class="hljs-keyword">class</span>-validator <span class="hljs-keyword">class</span>-transformer</code><button type="button" class="clipit" onclick="copyToClickBoard(3)">Copiar código</button></pre>
      <p>Nosso próximo passo é habilitar o uso global de pipes no NestJS. Faremos isso por meio da variável
        <code>app</code>
        que se encontra no <code>main.ts</code> dentro de <code>src</code>. Usaremos o método
        <code>useGlobalPipes</code> e
        vamos passar como parâmetro para este método um objeto do tipo <code>ValidationPipe</code> que pode ser
        importado do
        pacote <code>@nestjs/commons</code>:
      </p>
      <pre class="prettyprint"><code class="hljs language-php">app.<span class="hljs-title function_ invoke__">useGlobalPipes</span>(
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ValidationPipe</span>({
          <span class="hljs-attr">transform</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">whitelist</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">forbidNonWhitelisted</span>: <span class="hljs-literal">true</span>,
        }),
     );</code><button type="button" class="clipit" onclick="copyToClickBoard()">Copiar código</button></pre>
      <p>Note que estamos configurando 3 opções para o <code>ValidationPipe</code>, sendo elas:</p>
      <ul>
        <li><code>transform: true</code>: com isso, indicamos que queremos que o pipe transforme o JSON recebido na
          requisição para um objeto da classe que vamos usar como tipo do parâmetro no método do controller decorado com
          o
          <code>@Body</code>.
        </li>
        <li><code>whitelist: true</code>: Essa configuração indica que as chaves do JSON devem ser iguais ao do objeto
          no
          qual o JSON será transformado, ignorando chaves que não são pareáveis a atributos do objeto.</li>
        <li><code>forbidNonWhitelisted: true</code>: Através dessa configuração, indicamos que qualquer chave que vier
          que
          não tiver par no objeto final deverá causar um erro, o que sinaliza que o cliente da nossa API está tentando
          enviar dados que não aceitamos.</li>
      </ul>
      <p>Agora, podemos escrever nossa validação. Dentro da pasta <code>src/usuario</code>, criaremos a pasta
        <code>dto</code>, onde criaremos classes que definem o formato e os tipos dos dados que aceitaremos para criar
        um
        usuário. Vamos fazer isso dentro de um arquivo chamado <code>CriaUsuario.dto.ts</code>, que inicialmente terá
        este
        corpo:
      </p>
      <pre class="prettyprint"><code class="hljs language-typescript" id="code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CriaUsuarioDTO</span> {  
      <span class="hljs-attr">nome</span>: <span class="hljs-built_in">string</span>;
      <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>;
      <span class="hljs-attr">senha</span>: <span class="hljs-built_in">string</span>;
    }</code><button type="button" class="clipit" onclick="copyToClickBoard()">Copiar código</button></pre>
      <p>A classe <code>CriaUsuarioDTO</code> já tem formato e tipos definidos. Então, agora podemos usar os decorators
        do
        <code>class-validator</code> para não só validar cada um dos atributos dos objetos dessa classe, como também
        para
        definir as mensagens de erro:
      </p>
      <pre class="prettyprint"><code class="hljs language-less"><span class="hljs-selector-tag">export</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">CriaUsuarioDTO</span> {
      <span class="hljs-variable">@IsNotEmpty</span>({ <span class="hljs-attribute">message</span>: <span class="hljs-string">'O nome não pode ser vazio'</span> })
      <span class="hljs-attribute">nome</span>: string;
    
      <span class="hljs-variable">@IsEmail</span>(undefined, { <span class="hljs-attribute">message</span>: <span class="hljs-string">'O e-mail informado é inválido'</span> })
      <span class="hljs-attribute">email</span>: string;
    
      <span class="hljs-variable">@MinLength</span>(<span class="hljs-number">6</span>, { <span class="hljs-attribute">message</span>: <span class="hljs-string">'A senha precisa ter pelo menos 6 caracteres'</span> })
      <span class="hljs-attribute">senha</span>: string;
    }</code><button type="button" class="clipit" onclick="copyToClickBoard()">Copiar código</button></pre>
      <p>Aqui validamos que o nome não pode ser vazio, o e-mail precisa ser válido e a senha precisa ter pelo menos 6
        caracteres.</p>
      <p>Por último, só precisamos ir no <code>usuario.controller.ts</code> e indicar no método <code>criaUsuario</code>
        que
        o objeto recebido no body da requisição, terá o tipo <code>CriaUsuarioDTO</code>:</p>
      <pre class="prettyprint"><code class="hljs language-less"><span class="hljs-variable">@Post</span>()
     async <span class="hljs-built_in">criaUsuario</span>(<span class="hljs-variable">@Body</span>() <span class="hljs-attribute">dadosDoUsuario</span>: CriaUsuarioDTO) {
        <span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.usuarioRepository</span><span class="hljs-selector-class">.salvar</span>(dadosDoUsuario);
        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">dadosDoUsuario</span>;
     }</code><button type="button" class="clipit" onclick="copyToClickBoard()">Copiar código</button></pre>
      <p>Pronto, já conseguimos validar que nenhum usuário será criado sem um nome, e-mail válido e com uma senha com
        menos
        de 6 caracteres.</p>
    </div>
  </section>

  <section>
    <h2>Validação do produto</h2>
    <div class="formattedText" data-external-links="">
      <p>Para validar produtos, precisamos quebrar o problema dessa validação em partes. Primeiro, vamos relembrar como
        é o
        JSON que precisamos enviar para cadastrar um produto:</p>
      <pre
        class="prettyprint"><code class="hljs language-json" id="4"><span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"nome"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Figura de ação Marvel Homem Aranha Olympus Homem Aranha E6358 de Hasbro Classic"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"valor"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">70.0</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"quantidadeDisponivel"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"descricao"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Produto novo, bem acabado, alegria para colecionadores"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"caracteristicas"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"nome"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Fabricante"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"descricao"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Iron Studios"</span>
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"nome"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"material"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"descricao"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Plástico"</span>
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"imagens"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"url"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"https://i.imgur.com/dwDZICq.jpg"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"descricao"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Imagem do Homem Aranha"</span>
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"categoria"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Colecionáveis"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"dataCriacao"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2022-10-12T14:22:53.496Z"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"dataAtualizacao"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2022-10-12T14:22:53.496Z"</span>
    <span class="hljs-punctuation">}</span></code><button type="button" class="clipit" onclick="copyToClickBoard(4)">Copiar código</button></pre>
      <p>Claramente, podemos quebrar esse JSON em algumas partes. Podemos observar que qualquer chave do JSON que tem
        uma
        lista como valor pode ser representada como uma classe diferente. Um exemplo seria as características de um
        produto
        que possuem, por enquanto, o nome do fabricante e o material do qual é feito o produto. Poderíamos separar isso
        em
        uma classe: </p>
      <pre class="prettyprint"><code class="hljs language-typescript" id="code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CaracteristicaProdutoDTO</span> {
      <span class="hljs-attr">nome</span>: <span class="hljs-built_in">string</span>;
      <span class="hljs-attr">descricao</span>: <span class="hljs-built_in">string</span>;
    }</code><button type="button" class="clipit" onclick="copyToClickBoard()">Copiar código</button></pre>
      <p>A mesma ideia é válida para a validação das Imagens do produto. Isso nos geraria uma classe
        <code>CriaProdutoDTO</code> parecida com a que se encontra abaixo:
      </p>
      <pre class="prettyprint"><code class="hljs language-css">export class CriaProdutoDTO {
      nome: string;
      valor: number;
      quantidade: number;
      descricao: string;
      caracteristicas: CaracteristicaProdutoDTO[];
      imagens: ImagemProdutoDTO[];
      categoria: string;
    }</code><button type="button" class="clipit" onclick="copyToClickBoard()">Copiar código</button></pre>
      <p>A pergunta que fica é: como fazer o pipe validar um atributo que na verdade é uma lista de objetos de outra
        classe
        que também possui suas próprias validações? O <code>class-validator</code> nos ajuda nisso também. </p>
      <p>Primeiro, precisamos validar que deve ser uma lista, ou melhor, um array. Para isso temos o decorator
        <code>@IsArray()</code>. Segundo, precisamos dizer para o <code>class-validator</code> que ele deve validar o
        objeto
        que está sendo referenciado pelo atributo, ou seja, precisa fazer a validação aninhada ao atributo validado,
        para
        isso usaremos o decorator <code>@ValidateNested()</code>.
      </p>
      <p>E, por último, precisamos informar o tipo do objeto ao qual o atributo faz referência, para transformar o
        objeto do
        atributo no tipo correto e para isso usaremos o decorator <code>@Type()</code> que por parâmetro espera uma
        função
        que retorne o tipo ao que o atributo está se referindo. </p>
      <p>Juntando tudo, teremos uma validação que segue o seguinte formato para as características do produto:</p>
      <pre
        class="prettyprint"><code class="hljs language-less"><span class="hljs-variable">@ValidateNested</span>()
    <span class="hljs-variable">@IsArray</span>() 
    <span class="hljs-variable">@Type</span>(() =&gt; CaracteristicaProdutoDTO)
    <span class="hljs-attribute">caracteristicas</span>: CaracteristicaProdutoDTO[];</code><button type="button" class="clipit" onclick="copyToClickBoard()">Copiar código</button></pre>
      <p>Com isso em mente, crie a validação de criação de produtos. Elas precisam atender aos critérios abaixo:</p>
      <ul>
        <li>O nome do produto não pode ser vazio;</li>
        <li>O valor do produto precisa ser um número positivo (não pode ser zero) e ter até duas casas decimais;</li>
        <li>A quantidade precisa ser um número igual ou maior que zero;</li>
        <li>A descrição não pode ser vazia ou maior que 1000 caracteres;</li>
        <li>A lista de características do produto precisa ter pelo menos 3 itens;</li>
        <li>A lista de imagens do produto precisa ter pelo menos 1 item;</li>
        <li>A categoria do produto não pode ser vazia.</li>
      </ul>
      <p>Algumas dessas validações não exploramos aqui, mas estão todas descritas na documentação do class-validator que
        você pode acessar <a href="https://github.com/typestack/class-validator#validation-decorators"
          rel="nofollow noopener" target="_blank">neste link</a>.</p>
    </div>
  </section>

  <section>
    <h2>Validando o email</h2>
    <div class="formattedText" data-external-links="">
      <p>Validar que um e-mail já foi usado por outro usuário da nossa lógica precisa ser feito de forma assíncrona,
        visto
        que precisamos ir até o banco de dados ou mesmo outro serviço e esperar uma resposta. </p>
      <p>Dito isso, crie um novo <strong><em>provider</em></strong>, que decorado com
        <code>@ValidatorConstraint({ async: true })</code>, implemente a interface
        <code>ValidatorConstraintInterface</code>. Este provider também deve receber como dependência no construtor o
        repositório de usuários, afinal, é o repositório que faz interação com o banco de dados.
      </p>
      <p>A interface <code>ValidatorConstraintInterface</code> no seu método <code>validate</code>, espera que
        retornemos um
        valor booleano que indique se a validação foi um sucesso ou não. Se retornarmos o valor false, o erro de
        validação
        deve ser apresentado.</p>
      <p>Para criar o decorator que executa a validação personalizada que acabamos de descrever, precisamos criar uma
        função. O nome desta função será o nome do decorator. E, como parâmetro, essa função deve receber um objeto do
        tipo
        <code>ValidationOptions</code>, interface importada do pacote <code>class-validator</code>.
      </p>
      <p>Nossa função decorator deve retornar como resultado uma nova função que tem como parâmetros o objeto a ser
        validado
        e o nome da propriedade que será validada. </p>
      <p>Esta segunda função deve executar o registro deste decorator no <code>class-validator</code> por meio do uso da
        função <code>registerDecorator</code> que recebe como argumento um objeto, informando o target alvo da
        validação, a
        propriedade a ser validada, as opções de validação, as constraints e por último o validator (classe que já
        escrevemos antes).</p>
    </div>
  </section>

  <section>
    <h2>Relacionando produto e usuário</h2>
    <div class="formattedText" data-external-links="">
      <p>Cada usuário na loja pode cadastrar um ou mais produtos; porém, não temos ainda nenhuma relação entre o usuário
        e o
        produto. Por isso, precisamos garantir que o campo <code>usuarioId</code> seja enviado no corpo do POST para
        criação
        de um produto. </p>
    </div>
  </section>

  <section>
    <h2>Atualizar e remover usuário</h2>
    <div class="formattedText" data-external-links="">
      <p>Para finalizar nosso CRUD, precisamos permitir a atualização dos dados de um usuário e também a remoção desse
        usuário da nossa aplicação. Antes disso, vamos fazer dois pequenos incrementos na nossa aplicação. </p>
      <p>O primeiro desses incrementos é criar uma representação real do que é um usuário na nossa aplicação, a entidade
        usuário. Essa classe possui como atributos o nome, email, senha e id do usuário. Por fim, devemos usar essa
        entidade
        nos lugares onde lidamos com o usuário, ou seja, no repositório. A inicialização do nosso array de usuários deve
        ficar como se encontra abaixo:</p>
      <pre
        class="prettyprint"><code class="hljs language-cpp" id="5"><span class="hljs-keyword">private</span> usuarios: UsuarioEntity[] = [];</code><button type="button" class="clipit" onclick="copyToClickBoard(5)">Copiar código</button></pre>
      <p>Há mais lugares onde podemos usar nossa entidade de usuário como no controller, ao criar um usuário novo a
        partir
        do DTO de criação de usuário. </p>
      <p>O segundo incremento é criar um novo DTO responsável por representar um usuário em nossa listagem; este deve
        apenas
        exibir o id e o nome do usuário. E atenção: já devemos refatorar nossa listagem de usuários para usar este novo
        DTO.
      </p>
      <p>Para atualizar um usuário, precisamos criar um novo DTO, muito parecido com o de criação de usuário, porém, com
        todos os campos opcionais. Afinal, não sabemos quais campos o usuário irá atualizar. Contudo, caso o campo seja
        enviado, ele precisa passar pelas mesmas validações de criação de um usuário novo, ou seja, o e-mail não pode
        ter
        sido usado por outro usuário, etc.</p>
      <p>Para validar um campo de forma opcional, podemos usar o decorator <code>@IsOptional</code> do
        <code>class-validator</code> como no exemplo abaixo:
      </p>
      <pre
        class="prettyprint"><code class="hljs language-less"><span class="hljs-variable">@MinLength</span>(<span class="hljs-number">6</span>, { <span class="hljs-attribute">message</span>: <span class="hljs-string">'A senha precisa ter pelo menos 6 caracteres'</span> })
    <span class="hljs-variable">@IsOptional</span>()
    <span class="hljs-attribute">senha</span>: string;</code><button type="button" class="clipit" onclick="copyToClickBoard()">Copiar código</button></pre>
      <p>Além disso, precisamos ter o cuidado de não permitir que o usuário atualize o próprio id no repositório, visto
        que
        vamos receber como parâmetro um objeto parcial de um usuário no método <code>atualiza</code>: </p>
      <pre
        class="prettyprint"><code class="hljs language-typescript" id="code"><span class="hljs-keyword">async</span> <span class="hljs-title function_">atualiza</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span>, dadosDeAtualizacao: Partial&lt;UsuarioEntity&gt;</span>) {}</code><button type="button" class="clipit" onclick="copyToClickBoard()">Copiar código</button></pre>
      <p>Para remover um usuário, o processo é um pouco mais simples: precisamos apenas do ID do usuário enviado como
        parâmetro na URL usando o método DELETE. </p>
      <pre
        class="prettyprint"><code class="hljs language-less"> <span class="hljs-variable">@Delete</span>(<span class="hljs-string">'/:id'</span>)
     async <span class="hljs-built_in">removeUsuario</span>(<span class="hljs-variable">@Param</span>(<span class="hljs-string">'id'</span>) <span class="hljs-attribute">id</span>: string) {}</code><button type="button" class="clipit" onclick="copyToClickBoard()">Copiar código</button></pre>
      <p>Um ponto de atenção importante é que tanto na atualização dos dados do usuário, quanto na remoção, precisamos
        retornar como resposta um objeto com uma mensagem indicando se o usuário foi removido ou atualizado, assim como
        os
        dados desse usuário, algo semelhante ao que se encontra abaixo:</p>
      <pre class="prettyprint"><code class="hljs language-kotlin"><span class="hljs-keyword">return</span> {
       usuario: usuarioRemovido,
      messagem: <span class="hljs-string">'usuário removido com suceso'</span>,
    };</code><button type="button" class="clipit" onclick="copyToClickBoard()">Copiar código</button></pre>
    </div>
  </section>

  <section>
    <h2>Atualizando e Removendo Produto</h2>
    <div class="formattedText" data-external-links="">
      <p>Chegou o momento de replicar tudo que fizemos para finalizar o CRUD de usuários, para produtos. Segue uma lista
        simples com tudo que precisamos fazer:</p>
      <ol>
        <li>Criar a entidade de produto, essa será idêntica ao <code>CriaProdutoDTO</code> que já escrevemos antes;
          porém,
          com um atributo extra, o ID do produto que será um UUID;</li>
        <li>Usar a entidade de produto nos métodos do repositório de produtos;</li>
        <li>Ajustar o código do controller de produtos para que o mesmo crie um objeto da entidade produto ao tentar
          salvar
          um produto no repositório;</li>
        <li>Criar o DTO de atualização de produto; este é idêntico ao de criação de produto, porém, com todos os campos
          opcionais com exceção do id do produto e o id do usuário;</li>
        <li>Escrever o método <code>atualiza</code> no repositório de produto, no qual, dado um id e os dados de
          atualização
          de um produto, o método atualiza os valores que foram recebidos, filtrando o id do produto e do usuário, sendo
          que
          estes valores não podem ser atualizados;</li>
        <li>Criar o método <code>atualiza</code> no controller de produto que responde ao método HTTP Put, que recebe
          como
          parâmetro de URL o id do produto a ser atualizado e como corpo da requisição os dados do produto com as
          validações
          já presentes no DTO. E assim haver o retorno ao final de uma mensagem que informa que o produto foi atualizado
          com
          sucesso, assim como os dados do produto;</li>
        <li>Escrever o método <code>remove</code> no repositório, no qual, dado um id, busca o produto e o remove da
          lista
          de produtos, retornando ao final os dados do produto removido;</li>
        <li>Escrever o método <code>remove</code> no controller de produtos que recebe como parâmetro de URL o id do
          produto
          e executa a remoção do produto, e retorna como resposta uma mensagem informando que o produto foi removido,
          assim
          como os dados do produto. Este método no controller deve responder ao método DELETE do HTTP.</li>
      </ol>
    </div>
  </section>

  <section>
    <h2>Relacionamento entre recursos</h2>
    <div class="formattedText" data-external-links="">
      <p>Em APIs Restful, você pode ter endpoints isolados, ou seja, lidam com as operações de CRUD de forma isolada sob
        um
        recurso só e endpoints que lidam com relacionamentos ou agregações.</p>
      <p>Nos endpoints que lidam com relacionamentos/agregações, dependendo do tipo de relacionamento, a recomendação
        geral
        é que esse relacionamento seja expresso também nas URLs dos recursos. </p>
      <p>Vejamos nosso exemplo da loja: Um usuário possui produtos. Sendo assim, os produtos da loja estão com um
        relacionamento forte com seus usuários. De fato, o usuário cria e remove produtos como bem entender. Sendo
        assim, a
        recomendação geral é que o CRUD de produtos tivesse endpoints relativos ao de usuários. O que isso quer dizer na
        prática? A URL a seguir demonstra a relação entre produtos e usuário:</p>
      <pre
        class="prettyprint"><code class="hljs language-bash" id="6">http://localhost:3000/usuarios/1234/produtos</code><button type="button" class="clipit" onclick="copyToClickBoard(6)">Copiar código</button></pre>
      <p>O número <code>1234</code> na URL representa o usuário com aquele identificador. O <code>/produtos</code> logo
        após
        o identificador de usuário, representa o endpoint raiz de operações do CRUD para produtos daquele usuário.
        Considerando isso, teríamos o seguinte esquema de CRUD para produtos:</p>
      <ul>
        <li><code>POST http://localhost:3000/usuarios/1234/produtos</code>, para criar um produto;</li>
        <li><code>GET http://localhost:3000/usuarios/1234/produtos</code>, para listar todos os produtos;</li>
        <li><code>PUT/PATCH  http://localhost:3000/usuarios/1234/produtos/4321</code>, para atualizar um produto;</li>
        <li><code>DELETE http://localhost:3000/usuarios/1234/produtos</code>, para remover um produto.</li>
      </ul>
      <p>Durante nossas aulas, não seguimos este padrão para simplificar a construção geral da nossa loja. É importante
        ter
        isso em mente: não seguir uma recomendação ou um padrão precisa ser uma escolha consciente sobre os impactos
        dessa
        escolha. </p>
    </div>
  </section>
  <script src="./scripts.js"></script>
</body>

</html>